<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>TwoEasyEngine Camera Pan & Zoom</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: black;
    }

    #canvas {
      width: 100%;
      height: 100vh;
      display: block;
      touch-action: none; /* Prevent default pinch zooming by the browser */
      cursor: grab;
    }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>

  <script type="module">
    import * as Two from "/two-easy-engine/demos/two-easy-engine.js";

    // Setup renderer
    const canvas = document.getElementById("canvas");
    const camera = new Two.Camera2D();
    const scene = new Two.Scene();
    const render = new Two.Render2D(canvas, scene, camera, {
      width: window.innerWidth,
      height: window.innerHeight,
      devicePixelRatio: window.devicePixelRatio || 1,
      backgroundColor: "#111",
    });

    // Create colorful grid
    const gridSize = 10;
    const spacing = 100;

    for (let x = -gridSize; x <= gridSize; x++) {
      for (let y = -gridSize; y <= gridSize; y++) {
        const hue = ((x + gridSize) / (gridSize * 2)) * 360;
        const fillStyle = new Two.HslaColor(hue, 80, 50, 1);
        const material = new Two.BasicMaterial({ fillStyle });
        const geometry = new Two.RectGeometry(60, 60);
        const mesh = new Two.Mesh(geometry, material);
        mesh.transform.position.set(x * spacing, y * spacing);
        scene.add(mesh);
      }
    }

    // Camera Controls (mouse + touch)
    let isDragging = false;
    let lastPos = { x: 0, y: 0 };
    let lastTouchDist = null;

    // Mouse controls
    canvas.addEventListener("mousedown", (e) => {
      isDragging = true;
      lastPos.x = e.clientX;
      lastPos.y = e.clientY;
      canvas.style.cursor = "grabbing";
    });

    window.addEventListener("mouseup", () => {
      isDragging = false;
      canvas.style.cursor = "grab";
    });

    canvas.addEventListener("mousemove", (e) => {
      if (!isDragging) return;
      const dx = e.clientX - lastPos.x;
      const dy = e.clientY - lastPos.y;
      lastPos.x = e.clientX;
      lastPos.y = e.clientY;
      camera.transform.position.x -= dx / camera.zoom;
      camera.transform.position.y -= dy / camera.zoom;
    });

    // Mouse wheel zoom
    canvas.addEventListener("wheel", (e) => {
      e.preventDefault();
      const zoomFactor = 1.1;
      camera.zoom *= e.deltaY < 0 ? zoomFactor : 1 / zoomFactor;
      camera.zoom = Math.max(0.1, Math.min(5, camera.zoom));
    });

    // Touch controls
    canvas.addEventListener("touchstart", (e) => {
      if (e.touches.length === 1) {
        // One finger: start pan
        lastPos.x = e.touches[0].clientX;
        lastPos.y = e.touches[0].clientY;
      } else if (e.touches.length === 2) {
        // Two fingers: start pinch
        lastTouchDist = getTouchDistance(e.touches);
      }
    }, { passive: false });

    canvas.addEventListener("touchmove", (e) => {
      e.preventDefault();

      if (e.touches.length === 1 && lastTouchDist === null) {
        // Pan
        const dx = e.touches[0].clientX - lastPos.x;
        const dy = e.touches[0].clientY - lastPos.y;
        lastPos.x = e.touches[0].clientX;
        lastPos.y = e.touches[0].clientY;
        camera.transform.position.x -= dx / camera.zoom;
        camera.transform.position.y -= dy / camera.zoom;
      } else if (e.touches.length === 2) {
        // Pinch zoom
        const dist = getTouchDistance(e.touches);
        if (lastTouchDist !== null) {
          const zoomChange = dist / lastTouchDist;
          camera.zoom *= zoomChange;
          camera.zoom = Math.max(0.1, Math.min(5, camera.zoom));
        }
        lastTouchDist = dist;
      }
    }, { passive: false });

    canvas.addEventListener("touchend", () => {
      lastTouchDist = null;
    });

    function getTouchDistance(touches) {
      const dx = touches[0].clientX - touches[1].clientX;
      const dy = touches[0].clientY - touches[1].clientY;
      return Math.hypot(dx, dy);
    }

    // Resize
    window.addEventListener("resize", () => {
      render.setSize(window.innerWidth, window.innerHeight);
    });

    // Start render loop
    render.requestAnimationFrame();
  </script>
</body>
</html>
